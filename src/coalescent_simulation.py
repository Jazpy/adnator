import sys
import msprime
import tskit
import demes

from src.io import write_fasta_sequences


class CoalescentSimulation:
    '''
    Class representing a coalescent simulation run. This can include:
        - Genotype matrices as generated by msprime.
        - Ancestral sequence.
        - Simulation parameters.
    '''

    def __init__(self, config_d, demography=None):
        '''
        Create the simulation parameters, such as demography, focal populations, number of individuals, etc.

        At the moment only configuration file loading is supported, with the exception of being able
        to specify an msprime `Demography` object in addition to the configuration file if no
        demes-compatible file is specified inside the configuration file.

        Args:
            config_d (str): Configuration dictionary containing coalescent simulation parameters.
            demography (Demography, optional): msprime Demography object if none is specified in
                the configuration dictionary. Defaults to None.

        Raises:
            ValueError: On invalid configuration parameters.
        '''

        if 'demography' not in config_d and not demography:
            raise ValueError('No demography specified')
        if 'demography' in config_d and demography:
            raise ValueError('Demography object provided even though configuration already specifies it!')

        # Required parameters
        self.dem_model      = msprime.Demography.from_demes(demes.load(config_d['demography'])) or demography
        self.foc_pops       = config_d['focal_populations']
        self.foc_pops_sizes = config_d['focal_population_sizes']
        self.ref_pops       = config_d['reference_populations']
        self.ref_pops_sizes = config_d['reference_population_sizes']

        # General simulation parameters
        self.seq_len = config_d.get('sequence_length', 10_000)
        self.mu      = config_d.get('mutation_rate', 1.5e-8)
        self.rho_map = config_d.get('recombination_map')
        self.rho     = config_d.get('recombination_rate', None if self.rho_map else 1.5e-8)
        self.ploidy  = config_d.get('ploidy', 2)
        self.out_dir = config_d.get('output_directory', '.')

        self.foc_pops_times = config_d.get('focal_population_times', [0] * len(self.foc_pops))
        self.ref_pops_times = config_d.get('reference_population_times', [0] * len(self.ref_pops))

        if self.rho and self.rho_map:
            raise ValueError('"recombination_rate" and "recombination_map" parameters are both set!')

        # Set to None so we can build them only if needed
        self.trees = None
        self.ancestral_sequence = None


    def run(self):
        '''
        Run the coalescent simulation, simulates coalescent trees and mutations.
        '''

        # Build sample dictionaries for sim_ancestry()
        sample_sets = []
        for pop, size, time in zip(self.foc_pops, self.foc_pops_sizes, self.foc_pops_times):
            sample_sets.append(msprime.SampleSet(size, population=pop, time=time, ploidy=self.ploidy))
        for pop, size, time in zip(self.ref_pops, self.ref_pops_sizes, self.ref_pops_times):
            sample_sets.append(msprime.SampleSet(size, population=pop, time=time, ploidy=self.ploidy))


        # Run coalescent simulation
        self.trees = msprime.sim_ancestry(sample_sets, sequence_length=self.seq_len,
                                          ploidy=self.ploidy, demography=self.dem_model,
                                          recombination_rate=self.rho or self.rho_map)
        self.trees = msprime.sim_mutations(self.trees, rate=self.mu)

        # Map population string IDs to integer IDs
        self.pop_id_d = {}
        for p in self.trees.populations():
            self.pop_id_d[p.metadata['name']] = p.id

        # Build lists of sample nodes and IDs for later writing
        self.ref_samples = []
        self.ref_sample_ids = []
        for pop, size in zip(self.ref_pops, self.ref_pops_sizes):
            self.ref_samples.extend(self.trees.samples(population=self.pop_id_d[pop]))
            self.ref_sample_ids.extend([f'{pop}_{x}' for x in range(size * self.ploidy)])

        self.foc_samples = []
        self.foc_sample_ids = []
        for pop, size in zip(self.foc_pops, self.foc_pops_sizes):
            self.foc_samples.extend(self.trees.samples(population=self.pop_id_d[pop]))
            self.foc_sample_ids.extend([f'{pop}_{x}' for x in range(size * self.ploidy)])


    def write_sequences(self):
        '''
        Write fasta files for all of the simulated individuals.

        Raises:
            RuntimeError: If no coalescent simulation has taken place.

        Returns:
            List of tuples (metadata, filepath) of the written focal sequences
        '''

        if not self.trees:
            raise RuntimeError('Need to run coalescent simulation before writing VCFs!')

        if not self.ancestral_sequence:
            self.ancestral_sequence = tskit.random_nucleotides(self.seq_len)

        # Write samples in reference populations
        for pop in self.ref_pops:
            curr_samples = self.trees.samples(population=self.pop_id_d[pop])
            curr_seqs    = self.trees.alignments(reference_sequence=self.ancestral_sequence,
                                                 samples=curr_samples)

            write_fasta_sequences(f'{self.out_dir}/reference_sequences/', pop, curr_seqs, self.ploidy)

        # Write samples in focal populations
        ret = []

        for pop in self.foc_pops:
            curr_samples = self.trees.samples(population=self.pop_id_d[pop])
            curr_seqs    = self.trees.alignments(reference_sequence=self.ancestral_sequence,
                                                 samples=curr_samples)

            ret.extend(write_fasta_sequences(f'{self.out_dir}/focal_sequences/', pop,
                                             curr_seqs, self.ploidy))

        return ret
