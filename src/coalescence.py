import sys
import msprime
import tskit
import demes

from src.io import load_yaml, create_directory_structure


class CoalescentSimulation:
    '''
    Class representing a simulation run. This can include:
        - Genotype matrices as generated by msprime.
        - Ancestral sequence.
        - Simulation parameters
    '''

    def __init__(self, config_fp, demography=None):
        '''
        Create the simulation paramters, such as demography, focal populations, number of individuals, etc.

        At the moment only configuration file loading is supported, with the exception of being able
        to specify an msprime `Demography` object in addition to the configuration file if no
        demes-compatible file is specified inside the configuration file.

        Args:
            config_fp (str): Filepath for a YAML configuration file
            demography (Demography, optional): msprime Demography object if none is specified in
                configuration file. Defaults to None.

        Raises:
            ValueError: On invalid configuration.
        '''

        config_d = load_yaml(config_fp)

        if 'demography' not in config_d and not demography:
            raise ValueError('No demography specified')
        if 'demography' in config_d and demography:
            raise ValueError('Demography object provided even though configuration already specifies it!')

        # Required parameters
        self.dem_model      = msprime.Demography.from_demes(demes.load(config_d['demography'])) or demography
        self.foc_pops       = config_d['focal_populations']
        self.foc_pops_sizes = config_d['focal_population_sizes']
        self.ref_pops       = config_d['reference_populations']
        self.ref_pops_sizes = config_d['reference_population_sizes']

        # General simulation parameters
        self.seq_len = config_d.get('sequence_length', 10_000)
        self.mu      = config_d.get('mutation_rate', 1.5e-8)
        self.rho_map = config_d.get('recombination_map')
        self.rho     = config_d.get('recombination_rate', None if self.rho_map else 1.5e-8)
        self.ploidy  = config_d.get('ploidy', 2)
        self.out_dir = config_d.get('output_directory', '.')

        self.foc_pops_times = config_d.get('focal_population_times', [0] * len(self.foc_pops))
        self.ref_pops_times = config_d.get('reference_population_times', [0] * len(self.ref_pops))

        if self.rho and self.rho_map:
            raise ValueError('"recombination_rate" and "recombination_map" parameters are both set!')

        # Set to None so we can build them only if needed
        self.trees = None
        self.ancestral_sequence = None


    def run_coalescent_simulation(self):
        '''
        Run the coalescent simulation, simulates coalescent trees and mutations.
        '''

        # Build sample dictionaries for sim_ancestry()
        sample_sets = []
        for pop, size, time in zip(self.foc_pops, self.foc_pops_sizes, self.foc_pops_times):
            sample_sets.append(msprime.SampleSet(size, population=pop, time=time, ploidy=self.ploidy))
        for pop, size, time in zip(self.ref_pops, self.ref_pops_sizes, self.ref_pops_times):
            sample_sets.append(msprime.SampleSet(size, population=pop, time=time, ploidy=self.ploidy))


        # Run coalescent simulation
        self.trees = msprime.sim_ancestry(sample_sets, sequence_length=self.seq_len, ploidy=self.ploidy,
                                          demography=self.dem_model, recombination_rate=self.rho or self.rho_map)
        self.trees = msprime.sim_mutations(self.trees, rate=self.mu)

        # Map population string IDs to integer IDs
        self.pop_id_d = {}
        for p in self.trees.populations():
            self.pop_id_d[p.metadata['name']] = p.id

        # Build lists of sample nodes and IDs for later writing
        self.ref_samples = []
        self.ref_sample_ids = []
        for pop, size in zip(self.ref_pops, self.ref_pops_sizes):
            self.ref_samples.extend(self.trees.samples(population=self.pop_id_d[pop]))
            self.ref_sample_ids.extend([f'{pop}_{x}' for x in range(size * self.ploidy)])

        self.foc_samples = []
        self.foc_sample_ids = []
        for pop, size in zip(self.foc_pops, self.foc_pops_sizes):
            self.foc_samples.extend(self.trees.samples(population=self.pop_id_d[pop]))
            self.foc_sample_ids.extend([f'{pop}_{x}' for x in range(size * self.ploidy)])


    def write_sequences(self):
        '''
        Write fasta files for all of the simulated individuals.

        Raises:
            RuntimeError: If no coalescent simulation has taken place.
        '''

        if not self.trees:
            raise RuntimeError('Need to run coalescent simulation before writing VCFs!')

        if not self.ancestral_sequence:
            self.ancestral_sequence = tskit.random_nucleotides(self.seq_len)

        # Create directory structure if not already built
        create_directory_structure(self.out_dir)

        # Write samples in reference populations
        for pop in self.ref_pops:
            curr_samples = self.trees.samples(population=self.pop_id_d[pop])
            curr_seqs    = self.trees.alignments(reference_sequence=self.ancestral_sequence,
                                                 samples=curr_samples)

            # Write sequences in 60 character chunks
            for i, (sample, seq) in enumerate(zip(curr_samples, curr_seqs)):
                individual = i // self.ploidy
                chromosome = i %  self.ploidy
                out_fp = f'{self.out_dir}/reference_sequences/{pop}_{individual}_{chromosome}.fasta'
                with open(out_fp, 'w') as out_f:
                    out_f.write(f'>{pop}_{individual}_{chromosome}\n')
                    out_f.write('\n'.join([seq[x:x + 60] for x in range(0, len(seq), 60)]))

        # Write samples in focal populations
        for pop in self.foc_pops:
            curr_samples = self.trees.samples(population=self.pop_id_d[pop])
            curr_seqs    = self.trees.alignments(reference_sequence=self.ancestral_sequence,
                                                 samples=curr_samples)

            # Write sequences in 60 character chunks
            for i, (sample, seq) in enumerate(zip(curr_samples, curr_seqs)):
                individual = i // self.ploidy
                chromosome = i %  self.ploidy
                out_fp = f'{self.out_dir}/reference_sequences/{pop}_{individual}_{chromosome}.fasta'
                with open(out_fp, 'w') as out_f:
                    out_f.write(f'>{pop}_{individual}_{chromosome}\n')
                    out_f.write('\n'.join([seq[x:x + 60] for x in range(0, len(seq), 60)]))
